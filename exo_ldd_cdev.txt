...........................................................
. Linux Device Driver
. EnsiCaen training
...........................................................

Students : Abhay BARAKY
	   Tobias AGUIAR
	   
3A SATE G1
...........................................................
. Part#1: Linux Device Driver compilation
...........................................................

1.0) get linux_training from foad or usb stick

1.1) create a folder ~/ldd_training and work on it

1.2) write a module source in file mytuxit.c with :
   - license type "GPL"
   	GNU General Public License, is an open-source license meant for software.
   - Author's name:"www.ensicaen.com"
   	This is a macro that specifies who is writing the kernel module.
   - init method that logs compilation date and time (Help#1)
   	This is the function that will execute first when the Linux device driver is loaded into the kernel. When we install the module in the kernel with insmod, this is the function executed when specified in "module_init()"
   static int func_init(void){
	 printk(KERN_INFO "mytuxit init: %s %s\n",__DATE__, __TIME__);	
}

   - exit method
   This is the function that will execute last when the Linux device driver is unloaded from the kernel. When we delete the module with rmmod, the function in "module_exit()" will be executed. 
   static void func_exit(void){
  printk(KERN_INFO "mytuxit exit\n");
  }

1.3) check where are the kernel source header files (Help#2)
    If header files are not present, get it with the installation tool (Help#22)
    We can find the source headers at /lib/modules/$(shell uname -r)/build. We use $(shell uname -r) beacuse kernel version can change.

1.4) create your Makefile using the template
   - what does obj-m and xxx-objs mean ?
   - where is the build input used to compile the module ?
   obj-m means the kind of object we want to create, which is a module (that's why "-m"). xxx-objs specifies the files needed to compile the object.
   

1.5) compile the module (Help#3)
   - what file are generated ?
   EnsiCaen_ldd.o : the object file of the module - the result of compiling the C file.
   EnsiCaen_ldd.mod.o : file that contains the information about the module (Version information etc).
   EnsiCaen_ldd.mod.c : file that  contains the information about the module which are required at the time of inserting to the kernel
   EnsiCaen_ldd.mod : File that contains specifications of data objects created by the module.
   EnsiCaen_ldd.ko : file is the object file linked with some of kernel's data structures that are needed by him. The dynamic linker in the kernel that is in charge of loading kernel modules, expects to find the data structure the kernel puts in .ko file and will not be able to load its module without them.
   - what is EnsiCaen_ldd.mod.c ? It is a file that  contains the information about the module which are required at the time of inserting to the kernel, like version number and symbols which are not defined locally.
   If kernel source are not available or not all installed, update it (Help#19)
   
   make -C /lib/modules/$(shell uname -r)/build  M=`pwd` modules
   	- M=$PWD informs the kernel an external module is beign built by the absolute path where this module is located.
   	- -C /lib/modules/$(shell uname -r)/build is the directory where the kernel source is located, and the make command will change to the specified directory, and once it is finished, it will change back.
   	- modules is the default target for building external modules.

1.6) clean compliation (Help#4)
   - what has been removed ? All the files generated by the makefile.
	We can clean a compilation by doing the "make clean" command, which is going remove all generated files in the module directory only.
...........................................................
. Part#2: Linux Device Driver installation
...........................................................

2.1) manual installation: (Help#5)
   - install the module (if you get error: required key not available, check Help#18)
   - list all installed modules
   lsmod is a trivial program which nicely formats the contents of the
   /proc/modules, showing what kernel modules are currently loaded. Or we can simply do "cat /proc/modules"
   - use the lsmod command and compare (See figure 1 and 2).
   - pipe the lsmod to see only the module (See figure 1 and 2).
   - remove the module
   	We can remve the module with rmmod command.
   - check the module is not more there (See figure 1 and 2).

2.2) display system logs (Help#6)
   - how long was the module alive in the system ? It was alive until we did a rmmod command to remove the module.
	We can see the system log with the command dmesg or by doing tail /var/log/syslog

2.3) parameters usage (Help#7)
     add the param 'verbose' of type 'int' to the module so that
     it is silent when verbose is not used or set to '0'
     (printk are not displayed)
     	static int param_verbose=0;
 		(module_param_named(verbose,param_verbose,int,S_IRUGO);)-This macro is used to initialize the arguments. module_param takes three parameters: the name of the variable, its type, and a permissions mask to be used for an accompanying sysfs entry. 
	(MODULE_PARM_DESC(verbose, "0: silent, 1: verbose");)-This macro is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable.

2.4) Dump info about the module (Help#71)
	the modinfo command shows information about a module inserted in the kernel. (See figure3).
...........................................................
. Part#3: allocate character device region
...........................................................

3.1) update the source to support inode:
   - register the module EnsiCaen_ldd to a inode in the init methode (Help#8)
   - do forget to unregister when leaving (Help#9)
   - print the major and minor during the init (Help#10)
   	#include <linux/cdev.h>  - Library that contains the definition of structures of type struct cdev to represent char devices internally.
	#include <linux/fs.h> - Library that contains the definition of the structure that hold all the files operations tha can be done in the driver.
 	dev_t dev_num;
 	err = alloc_chrdev_region(&dev_num, 0, 1, "EnsiCaen_ldd");
 	if (err) return err;
	unregister_chrdev_region(dev_num, 1);
	printk(KERN_INFO "mytuxit init: (%d,%d)\n",MAJOR(dev_num), MINOR(dev_num));

3.2) check the inode
   - compile the module
   - install the module
   sudo insmod EnsiCaen_ldd.ko
   - check the inode number in /proc/devices (See figure4).
   - what are the major and minor number ?
   	 The major number identifies the driver associated with the device. A major number can also be shared by multiple device drivers. The device driver uses the minor number  to distinguish individual physical or logical devices, because many devices may use the same major number.
   - compare with system log (See figure 5).

3.3) connection to the file system
   - bind the file system to the inode (Help#11)
   sudo mknod /dev/EnsiCaen_Device c 511 0
   - ensure device file is readable by all (Help#12)
   chmod 777 /dev/EnsiCaen_Ldd (give all the rights to the device).
   - remove it (Help#13)
   sudo rm -f /dev/EnsiCaen_Device

3.4) Simplify the verification process using 2 scripts:
   ./install.sh for module insertion
   ./clean.sh for module removal

...........................................................
. Part#4: character device interface
...........................................................

4.1) create a file operation structure containing open, release and read methods (Help#14)
	int cdev_open(struct inode *pInode, struct file *pFile) {;}
 int cdev_release(struct inode *pInode, struct file *pFile) {;}
 ssize_t cdev_read(struct file *fp, char __user *buffer, size_t len, loff_t *offset) {;}
 struct file_operations cdev_fops = {
   owner:    THIS_MODULE,
   open:     cdev_open,
   release:  cdev_release,
   read:     cdev_read
   // unlocked_ioctl: cdev_ioctl,
 };
 The file_operations structure is defined in linux/fs.h, and holds pointers to functions defined by the driver that perform various operations on the device, as write and read.  

4.2) initialise a struct cdev mycdev with this file operation structure (Help#15)
   - what's happen if the cdev_add return value is not check ?
   	It means a device number couldn't be associated with the module created, and therefore the driver won't be found by the kernel.
   - and why is the cdev_del method call ?
   	To free the device alocation when it is no longer in use.
   - use it also in the exit method ?
   	It should be called on the exit method.
   - which one shall be called first before leaving: cdev_del(&char_dev); or unregister_chrdev_region(dev_num, 1);
   cdev_del(&char_dev) should be called first, and then the second method can be called.

<---- goal#1 - mercredi ---->
   
4.3) Implement a read method of the cdev that returns a constant string 'read method call' to userland
     check if it's working with the command
     cat /dev/EnsiCaenDevice
     Be carreful to the return value of the read method, it shall be stricly the number of bytes read
     **********************************************************************
     (See figure 6)
     const char kernel_buffer[LOCAL_BUF_SIZE] = "read method call\n";
	ssize_t my_module_read(struct file *fp, char __user *buffer, size_t len, loff_t *offset) {
 	loff_t available = LOCAL_BUF_SIZE - *offset;
	if (len > available) len = available;
	
	/*
	printk(KERN_INFO "Sleeping...");
	wait_event_interruptible(wq, flag != 0);
	flag = 0;
	*/
	//copy_to_user (buffer, fp->private_data, len);
	copy_to_user (buffer, kernel_buffer + *offset, len);
	printk(KERN_DEBUG "mytuxit: red offset:%d len:%s", *offset, len);
	*offset += len;
	return len;	
 }
  **********************************************************************
4.4) what's happen if device number is wrong in cdev_add ?
     Read chapter 3 of LDD book ;)
     The kernel can't associate a driver to the number's device, which will lead to conflicts and compiling problems.

   
...........................................................
. Part#5: application from console and userland
...........................................................

5.1) Write a test application that uses the EnsiCaenDevice.
     The test application is written in file test.c
     It shall call the open, read and close API from userland and display the data returned by the read method.
	(See figure 7 and test.c file).
5.2) Improve the Makefile with the following traget:
appli:
	gcc test.c -o test

     how to get help for include in the application with open method :
     >man -k open
     >man 2 open
	(See figure 8 and test.c file)
5.3) Implement a write method in the driver that copy the userland input in a driver local buffer.
     Update the the read method so that the local buffer is returned to user land (and no more the constant string).
	(See figure 9)
5.4) Use simple sleep implementation (chapter 6 of ldd book, page 150) to block read until the first write has been done.
     For test purpose, use the test application and command line (prompt) in parallel.
     The test application is blocked by the read and unblocked while prompting this:
     echo "something" > /dev/EnsiCaenDevice
	(See figure 10 and 11 and tp_cdev_sleep folder).

5.5) (optional)use a IOCTL command (chapter 3 & 6 of ldd book) that turn the read block on or off on request from the application.
     Usage : ioctl(fd, ENSICAEN_READ_BLOCKING, activation);
     where activation = 0 => read is not blocked and will return an empty string
          activation = 1 => read is blocked until the first write
     (Help#16)
     The application is using the IOCTL like this : (Help#17)

5.6) (optional)Check the application ./test works and provide:
   - source of driver + test application 
   - copy of shell commands with expected answers

<---- goal#2 ---->
	
5.7) Improve the driver to allows 2 parallels access to the driver:
    Use the file structure parameter of cdev (in open, read, write, close method) and namely the private_data element
    Then instantiate dynamically 2 internal buffers in the driver using the kmalloc API (chapter 3 of ldd book)
    /!\ the sleep implementation is no more needed here
	(See figure 12 and tp_cdev folder)
5.8) Modify the test application so that is will manage 2 sessions with the driver (2 handles)
    Verify and provide:
    - source of driver + test application
    - copy of shell commands with expected answers
	
5.9) ok if you are there you have done very good progress in char device driver on Linux ;)
	
	
Command tips:

(Help#1) printk(KERN_INFO "mytuxit init: %s %s\n",__DATE__, __TIME__);
(Help#2) ls /lib/modules/.../build
(Help#21) sudo pacman -S linux-headers / sudo apt-get install linux-headers
(Help#3) make
(Help#4) make clean
(Help#5) :
 sudo insmod the_module.ko
 sudo rmmod the_module
 cat /proc/modules
(Help#6) dmesg (same as tail /var/log/syslog)
(Help#7) :
 static int param_verbose=0;
 module_param_named(verbose,param_verbose,int,S_IRUGO);
 MODULE_PARM_DESC(verbose, "0: silent, 1: verbose");
(Help#71) :
modinfo
(Help#8)
#include <linux/cdev.h>  
#include <linux/fs.h>
 dev_t dev_num;
 err = alloc_chrdev_region(&dev_num, 0, 1, "EnsiCaen_ldd");
 if (err) return err;
(Help#9) unregister_chrdev_region(dev_num, 1);
(Help#10) printk(KERN_INFO "mytuxit init: (%d,%d)\n",MAJOR(dev_num), MINOR(dev_num));
(Help#11) sudo mknod /dev/EnsiCaen_Device c major_number minor_number
(Help#12) sudo chmod 644 /dev/EnsiCaen_Ldd
(Help#13) sudo rm -f /dev/EnsiCaen_Device
(Help#14)
 int cdev_open(struct inode *pInode, struct file *pFile) {;}
 int cdev_release/close(struct inode *pInode, struct file *pFile) {;}
 ssize_t cdev_read(struct file *fp, char __user *buffer, size_t len, loff_t *offset) {;}
 struct file_operations cdev_fops = {
   owner:    THIS_MODULE,
   open:     cdev_open,
   release:  cdev_release,
   close:    cdev_close,
   read:     cdev_read
   // unlocked_ioctl: cdev_ioctl,
 };
(Help#15)
 cdev_init(&char_dev, &cdev_fops);
 char_dev.owner = THIS_MODULE;
 err = cdev_add(&char_dev, dev_num, 1);
 if (err){
   unregister_chrdev_region(dev_num, 1);
 }   
(Help#16)
long cdev_ioctl (struct file *fp, unsigned int cmd, unsigned long arg)
{

	int activ = 0;
	int err = 0;

	printk(KERN_INFO "mytuxit:%s\n",__func__);

	if (_IOC_DIR(cmd) & _IOC_READ)
		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
	else if (_IOC_DIR(cmd) & _IOC_WRITE)
		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
	if (err) return -EFAULT;

	switch (_IOC_NR(cmd))
	{
	        case 1:
		{
			printk(KERN_INFO "mytuxit:%s: NXP_READ_BLOCKING\n",__func__);
			if (copy_from_user(&activ,(void __user *)arg,sizeof(int)))
			{
				printk(KERN_INFO "mytuxit:%s: NXP_READ_BLOCKING: error on copy_from_user\n",__func__);
				return -EACCES;
			}
			printk(KERN_INFO "mytuxit:%s: NXP_READ_BLOCKING: activation=%d\n",__func__,(int)activ);
			if (activ == 0)
				read_activation = 0;
			else
				read_activation = 1;
			break;
		}

		default:
		{
			/* unrecognized ioctl */	
			printk(KERN_INFO "mytuxit:%s:unknown ioctl number: 0x%x/0x%x\n",__func__,cmd,_IOC_NR(cmd));
			return -ENOIOCTLCMD;
		}
	}
	return 0;
}

(Help#17)
/* Use 'k' as magic number */
#define NXP_IOCTL_READ_BLOCKING _IOW('k', 1, unsigned long *)
err = ioctl((int)fp, NXP_IOCTL_READ_BLOCKING, &activation);

(Help#18)
ERROR: could not insert module EnsiCaen_ldd.ko: Required key not available
sudo apt install mokutil
sudo mokutil --disable-validation (new password required at prompt)
After reboot, you are request to update the boot mode (secure boot prompt), then provide password.

(Help#19)
sudo apt-get install linux-generic
